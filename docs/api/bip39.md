# BIP-39 mnemonics

Specs: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki<br>
Wordlists: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md

!> This module only includes **english** wordlist to keep the library small for embedded devices. If you want to use another language you can provide your own wordlist to the functions.

!> Keep in mind that the **same entropy** converted to mnemonics in **different languages** lead to **different private keys**.

Wordlist can be accessed with `embit.bip39.WORDLIST`.

## `mnemonic_from_bytes`

Converts raw entropy bytes to mnemonic. Use `16` or `32` bytes - they are the most common in the industry. Lower than `16` bytes are allowed by the standard but not recommended as it can be bruteforced.

**Arguments**

- `entropy`: raw entropy bytes. Any length multiple `4` is allowed but it's recommended to use `16` or `32` bytes to get `12` or `24` words mnemomnics.
- `wordlist = WORDLIST`: list of words to use, english by default.

**Returns**

mnemonic string in the desired language.

**Example**

```python
from embit import bip39
import os

mnemonic = bip39.mnemonic_from_bytes(os.urandom(16))
print(mnemonic)
```

## `mnemonic_to_bytes`

Converts mnemonic back to raw entropy bytes.

Sometimes it's useful to convert mnemonic to bytes ignoring checksum - for example if you want to convert invalid mnemonic to valid. Invalid mnemonic can be generated by picking words at random from a hat.

**Arguments**

- `mnemonic`: string with a mnemonic.
- `ignore_checksum = False`: whether to check the mnemonic checksum or not.
- `wordlist = WORDLIST`: list of words to use, english by default.

**Returns**

raw entropy bytes. If will be `16` bytes for `12`-word mnemonic and `32` bytes for `24`-word mnemonic.

**Example**

This example takes an invalid mnemonic and converts it to valid one by fixing the checksum and maintaining maximum entropy:

```python
from embit import bip39

# invalid mnemonic
mnemonic = ("satoshi "*12).strip()
entropy = bip39.mnemonic_to_bytes(mnemonic, ignore_checksum=True)
fixed = bip39.mnemonic_from_bytes(entropy)
# >>> satoshi satoshi satoshi satoshi satoshi satoshi satoshi satoshi satoshi satoshi satoshi same
```


## `mnemonic_is_valid`

Check if mnemonic is valid.

**Arguments**

- `mnemonic`: string with a mnemonic to check.
- `wordlist = WORDLIST`: list of words to use, english by default.

**Returns**

`True` is mnemonic is valid or `False` otherwise

## `mnemonic_to_seed`

Converts mnemonic with optional password to a seed for bip32 root key generation.

**Arguments**

- `mnemonic`: string with a mnemonic.
- `password = ""`: string with a bip39 password - any number of any characters.
- `wordlist = WORDLIST`: list of words to use, english by default. Required to check validity of the mnemonic. Pass `None` if you don't want to check the language.

**Returns**

`64`-byte seed for bip32 key generation.

**Example**

```python
from embit import bip39, bip32

# generates a seed with default empty password
seed = bip39.mnemonic_to_seed("fruit chicken vote sun shine dry blood one process step robust night")

# raises as we didn't provide chinese wordlist
seed = bip39.mnemonic_to_seed("油 員 潑 紅 捐 焰 鄧 扶 季 針 及 踏", password="Yey!!!")

# returns 64-byte seed as we ignored wordlist check
seed = bip39.mnemonic_to_seed("油 員 潑 紅 捐 焰 鄧 扶 季 針 及 踏", password="Yey!!!", wordlist=None)

# convert seed to bip32 key
root = bip32.HDKey.from_seed(seed)
```

## `find_candidates`

This function is useful for autosuggesting when the user is entering a word.

**Arguments**

- `word_part`: string with first letters of the word
- `nmax = 5`: number of candidates to return
- `wordlist = WORDLIST`: list of words to use, english by default.

**Returns**

A list of at most `nmax` words that start with `word_part`.

**Example**

```python
from embit import bip39

bip39.find_candidates("sat")
# >>> ['satisfy', 'satoshi']

bip39.find_candidates("")
# >>> ['abandon', 'ability', 'able', 'about', 'above']
```
